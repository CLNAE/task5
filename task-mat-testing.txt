The "mat.in" file is generated with the help of a short Python script which i created and named "generator.py". The generator file has 2 parts:

a) the "generator" function
b) a 'for' statement that writes the generated lines into "mat.in"

a) Using the "random" module, the function selects a random number between 5 and 15 for the rows and columns of the matrix. Using a 'for' statement 
that stops after rows*columns iterations, it chooses at random between '1' and '0' and it adds the chosen value to an empty list named 'numb'. 
The 'numb' list contains the values that the matrix is made of. Everything that has been generated is converted to string and put into a "line" 
variable, following this format: 'rowsxcolumns:numb'.

b) Using "with open("mat.in", "w")", it overwrites the mat.in file. If the file doesn't exist, it is created. Using a for statement that stops after 
110000 iterations (the task asked for more than 100.000 lines, I decided to go for 110.000), it uses the "generator" function to generate
a new line, and then using "file.write(line + '\n')", it writes the line into "mat.in".




Proving the correctness of the mat.out information:

I will select 3 matrices at random from mat.in and I will attach next to each one of them the answer generated by the "mat.py" script.

5x11:0110001011101110000110111100000011001000101111110001011

01100010111
01110000110
11110000001
10010001011
11110001011

1 1 0


7x6:011110001101001010000001100111001111001011

011110
001101
001010
000001
100111
001111
001011

1 0 0


14x15:000111010010110100000010110001100011110000000011001111001110010011101100011001110111101110101100111000110001101110110110011010010100110011111001001011001100101001011101101101101110101111010110001111110101110101

000111010010110
100000010110001
100011110000000
011001111001110
010011101100011
001110111101110
101100111000110
001101110110110
011010010100110
011111001001011
001100101001011
101101101101110
101111010110001
111110101110101

2 0 2


The way mat.py works:
 
Briefly put, it translates each line from "mat.in" into a matrix. It searches for '1's in the matrix. When it finds one, it searches for other adjacent '1's. It counts how many neighboring '1's it has and saves 
their coordinates in a set. An isolated '1' (iso) has no other '1's around it. When it comes to an isolated cluster of two '1's (iso_clu2), both of the '1's have one adjacent 1 each and they only have eachother 
as 'neighbors'. When it comes to an isolated cluster of three '1's (iso_clu3), two of them have 1 neighbor, while one of them has two neighbors and they only have eachother as 'neighbors' (considering ONLY the 
variations of isolated clusters of three '1's SHOWN IN THE TASK DESCRIPTION).
1) If the set is empty it means that it has no adjacent '1's. It is surrounded only by edges and/or '0's. It increments 'iso' by one and marks this '1' as "verified", which means its surroundings have been checked. 
2) If the set has one value and the '1' that has those coordinates is not "verified" (it isn't part of another cluster already), iso_clu2 incremets by one. Both of the '1's are marked as verified.
3) If the set has two values and the '1's that have those coordinates are not "verified" (they aren't part of another cluster already), iso_clu3 increments by one. All three of the '1's are marked as verified.